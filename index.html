<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Tracking Interactive Site</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #videoElement {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            height: 225px;
            border-radius: 15px;
            border: 2px solid #00ffff;
            z-index: 10;
            opacity: 0.8;
        }
        
        #canvas3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #handCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 15;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        #status {
            color: #00ff00;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .controls {
            margin-top: 10px;
        }
        
        button {
            background: linear-gradient(45deg, #ff006e, #fb5607);
            border: none;
            color: white;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 0, 110, 0.4);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            font-size: 12px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="videoElement" autoplay muted></video>
        <canvas id="handCanvas"></canvas>
        <canvas id="canvas3d"></canvas>
        
        <div id="ui">
            <div id="status">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>
            <div class="controls">
                <button onclick="startCamera()">–ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
                <button onclick="addObject()">–î–æ–±–∞–≤–∏—Ç—å –æ–±—ä–µ–∫—Ç</button>
                <button onclick="resetScene()">–°–±—Ä–æ—Å —Å—Ü–µ–Ω—ã</button>
            </div>
        </div>
        
        <div id="instructions">
            <h3>üéÆ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:</h3>
            <p>‚Ä¢ –ü–æ–∫–∞–∂–∏—Ç–µ —Ä—É–∫—É –∫–∞–º–µ—Ä–µ</p>
            <p>‚Ä¢ –°–≤–µ–¥–∏—Ç–µ –ø–∞–ª—å—Ü—ã (–ø–∏–Ω—á) –¥–ª—è –∑–∞—Ö–≤–∞—Ç–∞</p>
            <p>‚Ä¢ –†–∞–∑–≤–µ–¥–∏—Ç–µ –ø–∞–ª—å—Ü—ã –¥–ª—è –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è</p>
            <p>‚Ä¢ –ü–µ—Ä–µ–º–µ—â–∞–π—Ç–µ —Ä—É–∫—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</p>
        </div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.20.0/build/cannon.min.js"></script>

    <script>
        class HandTracking3D {
            constructor() {
                this.init();
            }

            async init() {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                this.video = document.getElementById('videoElement');
                this.handCanvas = document.getElementById('handCanvas');
                this.handCtx = this.handCanvas.getContext('2d');
                this.canvas3d = document.getElementById('canvas3d');
                this.status = document.getElementById('status');
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è 3D —Å—Ü–µ–Ω—ã
                this.init3DScene();
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–∏–∑–∏–∫–∏
                this.initPhysics();
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä—É–∫
                this.initHandTracking();
                
                // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
                this.handPosition = { x: 0, y: 0, z: 0 };
                this.isPinching = false;
                this.grabbedObject = null;
                this.virtualHand = null;
                this.interactiveObjects = [];
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π —Ä—É–∫–∏
                this.createVirtualHand();
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                this.addInitialObjects();
                
                // –ó–∞–ø—É—Å–∫ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
                this.animate();
                
                this.updateStatus('–ì–æ—Ç–æ–≤! –ù–∞–∂–º–∏—Ç–µ "–ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É"');
            }

            init3DScene() {
                // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);
                
                // –ö–∞–º–µ—Ä–∞
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 5, 10);
                
                // –†–µ–Ω–¥–µ—Ä–µ—Ä
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas3d, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // –û—Å–≤–µ—â–µ–Ω–∏–µ
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // –ü–æ–ª
                const floorGeometry = new THREE.PlaneGeometry(20, 20);
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.8
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                floor.receiveShadow = true;
                this.scene.add(floor);
            }

            initPhysics() {
                // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–∑–∏—á–µ—Å–∫–æ–≥–æ –º–∏—Ä–∞
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                
                // –ü–æ–ª –≤ —Ñ–∏–∑–∏–∫–µ
                const floorShape = new CANNON.Plane();
                const floorBody = new CANNON.Body({ mass: 0 });
                floorBody.addShape(floorShape);
                floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(-1, 0, 0), Math.PI * 0.5);
                floorBody.position.set(0, -5, 0);
                this.world.add(floorBody);
            }

            initHandTracking() {
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                this.hands.onResults(this.onResults.bind(this));
            }

            createVirtualHand() {
                // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–æ–π 3D —Ä—É–∫–∏
                const handGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const handMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6,
                    emissive: 0x004444
                });
                
                this.virtualHand = new THREE.Mesh(handGeometry, handMaterial);
                this.virtualHand.castShadow = true;
                this.scene.add(this.virtualHand);
                
                // –≠—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è
                const glowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.virtualHand.add(glow);
            }

            addInitialObjects() {
                const colors = [0xff0080, 0x00ff80, 0x8000ff, 0xff8000, 0x0080ff];
                
                for (let i = 0; i < 5; i++) {
                    this.createInteractiveObject(
                        Math.random() * 6 - 3,
                        Math.random() * 3 + 2,
                        Math.random() * 6 - 3,
                        colors[i]
                    );
                }
            }

            createInteractiveObject(x, y, z, color) {
                // 3D –æ–±—ä–µ–∫—Ç
                const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: 0.3,
                    roughness: 0.4
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                
                // –§–∏–∑–∏—á–µ—Å–∫–æ–µ —Ç–µ–ª–æ
                const shape = new CANNON.Box(new CANNON.Vec3(0.4, 0.4, 0.4));
                const body = new CANNON.Body({ mass: 1 });
                body.addShape(shape);
                body.position.set(x, y, z);
                body.material = new CANNON.Material({ friction: 0.3, restitution: 0.3 });
                this.world.add(body);
                
                const obj = { mesh, body, isGrabbed: false };
                this.interactiveObjects.push(obj);
                return obj;
            }

            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: 1280, height: 720 } 
                    });
                    this.video.srcObject = stream;
                    
                    const camera = new Camera(this.video, {
                        onFrame: async () => {
                            await this.hands.send({ image: this.video });
                        },
                        width: 1280,
                        height: 720
                    });
                    camera.start();
                    
                    this.updateStatus('–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞! –ü–æ–∫–∞–∂–∏—Ç–µ —Ä—É–∫—É');
                } catch (err) {
                    this.updateStatus('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ: ' + err.message);
                }
            }

            onResults(results) {
                this.resizeCanvas();
                this.handCtx.clearRect(0, 0, this.handCanvas.width, this.handCanvas.height);
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    this.processHandLandmarks(landmarks);
                    this.drawHandLandmarks(landmarks);
                    this.updateStatus('–†—É–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞!');
                } else {
                    this.updateStatus('–ü–æ–∫–∞–∂–∏—Ç–µ —Ä—É–∫—É –∫–∞–º–µ—Ä–µ');
                }
            }

            processHandLandmarks(landmarks) {
                // –ü–æ–∑–∏—Ü–∏—è —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø–∞–ª—å—Ü–∞ (landmark 8)
                const indexTip = landmarks[8];
                const thumb = landmarks;
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ 3D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ
                this.handPosition.x = (indexTip.x - 0.5) * 10;
                this.handPosition.y = -(indexTip.y - 0.5) * 8;
                this.handPosition.z = indexTip.z * 5;
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π —Ä—É–∫–∏
                if (this.virtualHand) {
                    this.virtualHand.position.set(
                        this.handPosition.x,
                        this.handPosition.y,
                        this.handPosition.z
                    );
                }
                
                // –î–µ—Ç–µ–∫—Ü–∏—è –∂–µ—Å—Ç–∞ –ø–∏–Ω—á
                const distance = Math.sqrt(
                    Math.pow(indexTip.x - thumb.x, 2) +
                    Math.pow(indexTip.y - thumb.y, 2)
                );
                
                const wasPinching = this.isPinching;
                this.isPinching = distance < 0.05;
                
                // –õ–æ–≥–∏–∫–∞ –∑–∞—Ö–≤–∞—Ç–∞/–æ—Ç–ø—É—Å–∫–∞–Ω–∏—è
                if (this.isPinching && !wasPinching) {
                    this.tryGrabObject();
                } else if (!this.isPinching && wasPinching) {
                    this.releaseObject();
                }
                
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∑–∞—Ö–≤–∞—á–µ–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
                if (this.grabbedObject && this.isPinching) {
                    this.moveGrabbedObject();
                }
            }

            tryGrabObject() {
                let closestObject = null;
                let closestDistance = Infinity;
                
                this.interactiveObjects.forEach(obj => {
                    if (!obj.isGrabbed) {
                        const distance = this.virtualHand.position.distanceTo(obj.mesh.position);
                        if (distance < 2 && distance < closestDistance) {
                            closestDistance = distance;
                            closestObject = obj;
                        }
                    }
                });
                
                if (closestObject) {
                    this.grabbedObject = closestObject;
                    this.grabbedObject.isGrabbed = true;
                    this.grabbedObject.mesh.material.emissive.setHex(0x444444);
                    this.virtualHand.material.opacity = 0.9;
                }
            }

            releaseObject() {
                if (this.grabbedObject) {
                    this.grabbedObject.isGrabbed = false;
                    this.grabbedObject.mesh.material.emissive.setHex(0x000000);
                    this.grabbedObject = null;
                    this.virtualHand.material.opacity = 0.6;
                }
            }

            moveGrabbedObject() {
                if (this.grabbedObject) {
                    this.grabbedObject.body.position.set(
                        this.handPosition.x,
                        this.handPosition.y,
                        this.handPosition.z
                    );
                    this.grabbedObject.body.velocity.set(0, 0, 0);
                    this.grabbedObject.body.angularVelocity.set(0, 0, 0);
                }
            }

            drawHandLandmarks(landmarks) {
                this.handCtx.fillStyle = '#00ffff';
                this.handCtx.strokeStyle = '#00ffff';
                this.handCtx.lineWidth = 2;
                
                // –†–∏—Å–æ–≤–∞–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Ç–æ—á–µ–∫
                landmarks.forEach((landmark, index) => {
                    const x = landmark.x * this.handCanvas.width;
                    const y = landmark.y * this.handCanvas.height;
                    
                    this.handCtx.beginPath();
                    this.handCtx.arc(x, y, 3, 0, 2 * Math.PI);
                    this.handCtx.fill();
                });
                
                // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –ø–∞–ª—å—Ü–µ–≤
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], // –ë–æ–ª—å—à–æ–π –ø–∞–ª–µ—Ü
                    [0, 5], [5, 6], [6, 7], [7, 8], // –£–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π
                    [0, 9], [9, 10], [10, 11], [11, 12], // –°—Ä–µ–¥–Ω–∏–π
                    [0, 13], [13, 14], [14, 15], [15, 16], // –ë–µ–∑—ã–º—è–Ω–Ω—ã–π
                    [0, 17], [17, 18], [18, 19], [19, 20] // –ú–∏–∑–∏–Ω–µ—Ü
                ];
                
                connections.forEach(([start, end]) => {
                    const startPoint = landmarks[start];
                    const endPoint = landmarks[end];
                    
                    this.handCtx.beginPath();
                    this.handCtx.moveTo(
                        startPoint.x * this.handCanvas.width,
                        startPoint.y * this.handCanvas.height
                    );
                    this.handCtx.lineTo(
                        endPoint.x * this.handCanvas.width,
                        endPoint.y * this.handCanvas.height
                    );
                    this.handCtx.stroke();
                });
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∏–∑–∏–∫–∏
                this.world.step(1/60);
                
                // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è 3D –æ–±—ä–µ–∫—Ç–æ–≤ —Å —Ñ–∏–∑–∏–∫–æ–π
                this.interactiveObjects.forEach(obj => {
                    if (!obj.isGrabbed) {
                        obj.mesh.position.copy(obj.body.position);
                        obj.mesh.quaternion.copy(obj.body.quaternion);
                    }
                });
                
                // –í—Ä–∞—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
                const time = Date.now() * 0.0005;
                this.camera.position.x = Math.cos(time) * 12;
                this.camera.position.z = Math.sin(time) * 12;
                this.camera.lookAt(0, 0, 0);
                
                // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
                this.renderer.render(this.scene, this.camera);
            }

            resizeCanvas() {
                this.handCanvas.width = window.innerWidth;
                this.handCanvas.height = window.innerHeight;
            }

            updateStatus(message) {
                this.status.textContent = message;
            }

            addObject() {
                const colors = [0xff0080, 0x00ff80, 0x8000ff, 0xff8000, 0x0080ff];
                this.createInteractiveObject(
                    Math.random() * 6 - 3,
                    5,
                    Math.random() * 6 - 3,
                    colors[Math.floor(Math.random() * colors.length)]
                );
            }

            resetScene() {
                this.interactiveObjects.forEach(obj => {
                    this.scene.remove(obj.mesh);
                    this.world.remove(obj.body);
                });
                this.interactiveObjects = [];
                this.grabbedObject = null;
                this.addInitialObjects();
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è UI
        let handTracker;

        function startCamera() {
            if (handTracker) {
                handTracker.startCamera();
            }
        }

        function addObject() {
            if (handTracker) {
                handTracker.addObject();
            }
        }

        function resetScene() {
            if (handTracker) {
                handTracker.resetScene();
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('load', () => {
            handTracker = new HandTracking3D();
        });

        // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ–¥ —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            if (handTracker) {
                handTracker.camera.aspect = window.innerWidth / window.innerHeight;
                handTracker.camera.updateProjectionMatrix();
                handTracker.renderer.setSize(window.innerWidth, window.innerHeight);
                handTracker.resizeCanvas();
            }
        });
    </script>
</body>
</html>
